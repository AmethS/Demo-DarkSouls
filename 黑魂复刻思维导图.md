  
### 我们做了什么？
1. 实现角色移动，跳跃，翻滚坠落
2. 实现角色简单攻击和挨打
3. 实现角色的盾反和背刺
4. 实现角色与宝箱和拉杆的互动

### 分为几个模块？
*  **ActorController**  
	处理玩家的Input输入，控制角色的Collider，Rigibody以及朝向。  
	与状态机配合，实现角色的整个演出。   
	**包含JoystickInput/keyboardInput/Iuserinput/MyButton等，一些小但是很重要的模块**
  
*  **CamraController**  
	处理视角的移动。   

*  **ActorManager**  
	相当于队长，负责处理各个模块的信息以及向他们发出指令

*  **BattleManager**  
	利用OnTriggerEnter/Exit，实现对攻击的处理

*  **StateManager**  
    对角色状态，血量等信息的管理。  
	*（战斗系统只实现了一部分，所以模块现在比较简陋）*

*  **DirectorManager**  
	主要负责Timeline的Playable Assets配置

*  **WeaponManager**  
	实现对它下边的武器子物件的管理，也就是需要把武器模型放到它下边，便于管理。  
	WM下边还有个WeaponController小模块，负责处理武器信息，例如ATK。

*  **EventCasterManager /  InteractionManager**  
	相当与一个标记系统。ECM负责给GameObject贴标签，IM负责识别标签。用这套系统来处理“何时判定角色演出可以执行”这个问题，例如，处决，背刺，开宝箱这些特殊动画。  
	***需要与DM互动。***

*  **GameManager**  
	用于实现对游戏内物品的管理。现在只做到生成和替换角色手里的武器。

###  还编写了一些脚本用于解决问题
*  **IActorManagerInterfacer**  
	各个Manager的基类，增加代码的复用。  
	（*虽然起名是接口的方式，实际上是用作继承的基类*）、

*  **OnGroundSensor**  
	用于检测角色是否站在地上的模块，利用SendMessageUpwards实现对bool值的操作，这个bool用来向系统表明主角的状态。

*  **WeaponController/Factory/Data**  
	武器相关的小模块。

*  **LeftArmAnimFix**  
	解决罐头动画的小问题。  
	（*实际开发中并不需要程序去搞定这些*）  

*  **RootMotionControl**  
	解决动画中collider位移和动画不匹配的小问题。  
   （*实际开发中并不需要程序去搞定这些*）  

*  **TriggerControl**  
	清除动画的triiger。  

*  **FSM系列**  
	用于实现在状态机切换动画时，对相关参数的处理。

****

###动画系统（第一季重难点）
  
  动画的重要性不必多说。这里想简明的说一下整个动画系统搭建的框架，逻辑以及与ActorContrller的互动，以及一些比较重要的细节。

*  **状态机/Animator**  
	用于编辑动画间的逻辑。简而言之，告诉系统什么时候播放什么动画，怎么播，在谁的身上播放动画。
   *  **参数/Parameters**  
	标记系统。利用这些标记告诉别的系统该做什么。这一部分也是最考验逻辑编写的地方。
   *  **子状态机**    
	简而言之，相当于一个文件夹，把一堆组合好的状态放进一个新的状态，提高可读性。  
*  **动画/Animation Clip**    
	储存动画的文件。可以进行一系列的修改。教程里经常调整动画里模型的位移。
   *  **事件/Event**  
    动画的一个子系统，允许在动画运行到特定帧的时候调用函数。攻击时，武器攻击判定的有效帧，就是用这个模块实现的。
*  **FSM系统**  
	当状态机播放动画，动画处于开、，结尾，或者正在播放时，就可以在这这个时刻调用函数，实现对参数的处理，完成一些想要的效果。这个系统实际上是利用了OnStateEnter/Exit/Update的函数，此处将其封装了，便于使用。  
  

####动画系统的设计思路
*  对于利用率较高的动作，利用状态机拉箭头的方式，实现动画的衔接。同时利用参数，一方面与StateManager沟通，告诉别的系统，此时角色处于什么状态。另一方面，利用setTrigger/setBool的方式，告诉状态机该执行什么动画（例如按下RB键，input脚本将hit trigger设为true，状态机读到了之后，播放攻击动画）  
简单说，状态机和其他模块是靠读写参数进行沟通的。  

*  使用率较低的动作（处决，背刺，开宝箱），则是用Timeline功能去实现。由于这些演出的触发条件比较复杂，还涉及到了与其他游戏元素的互动，如果都加入状态机，需要的逻辑非常复杂，而且可读性很低，提升了后续开发和维护的成本。

****

###重要模块的设计思路，遇到的问题和解决办法  
* **ActorController**  
	便于理解可以把整个Input逻辑分为三层.
	* 从手柄/键盘处获得输入数据  
	* 处理输入数据
	* 将处理后的数据作为参数，控制人物行动  
	
	其中一个问题就是当摇杆处于斜向时候，由于设计的问题，会导致向量的模长小于正向的模长。这里用把直角坐标系映射为椭圆坐标系的方法解决了问题。
	  
	除开移动。其余的，跳跃，攻击等动作，则需要用大量的IF逻辑去解决，有些繁杂。

	脚本最后则是提供给Animation Clip调用的函数，这里为了方便就把全部模块扔到了ActorController下边，**降低了部分可读性**。
* **ActorManager**  
	虽然设计之初把ActorManager作为整个系统的枢纽，但实际做到这，AM的代码量不多，主要是处理战斗逻辑。  
	具体内容是判定攻击是否有效，受击角色是否需要进行被打的动画，盾反是否成功，被打中后扣多少血等等。  
	AM的代码其实与BattleManager的耦合度很高，需要注意。

* **BattleManager**  
	底层的逻辑还是用OnTriggerEnter做collider的碰撞判定，把武器的collider设为trigger，如果与角色的判定框重合之后，则进行一次攻击判定。这里发现OnTriggerEnter的效果不够好，就选择了OnTrrigerExit方法。  
	为了制定一个合理的攻击范围的大小，这里利用了对攻击者和受击者形成的向量夹角进行限制的操作，保证攻击范围合理。个人觉得比较合理的角度是70° 。
	
* **CameraController**  
	camera的职责主要是让角度随着摇杆变化，由于整个游戏是第三人称视角，所以camera模块其实很重要。
	说实话这部分的写法相当tricky，这里并不能充分理解为什么要这样写。。。
	原理其实跟ActorController实现对角色的控制类似。读取输入信息，处理，利用处理后的信息控制camera。  
	做法是将右摇杆的X轴移动和Y轴移动分别对应到cameraHandle和playerHandle上边。X轴移动是控制整个player的object旋转，Y轴移动则是控制camera向上向下看。  
	控制player的object旋转用的是transform.Rotate函数。  
	控制camera向上向下看用的是transform.localEulerAngle函数。  
	由于是第三人称游戏，所以锁定是必不可少的功能。	
	锁定的核心的逻辑是把角色的前方固定到锁定对象上，并限制camera的仰角。
	具体写法是给playerHandle.transform.forward赋一个向量，向量的方向始终指向目标（两个点相减即可）。  
	cameraHandle.transform.LoocAt看向锁定物体的脚下。
	
* **DirectorManager**  
	这个模块功能很单一，就是装配playable asset，负责给AM调用，播放对应的函数。  
	而装配playable asset最核心的就是利用foreach循环去配置timeline中想要的信息。  
	而timeline的结构可以分为4层。  
	Time-Track-Clip-Values of Clip